<?php

/**
 * Common mappings for the Drupal 6 node migrations.
 */
class HrwebNodeMigration extends DrupalNode6Migration {

  public function __construct(array $arguments) {
    parent::__construct($arguments);
    //Map D6 input formats to OB text formats
    $this->addFieldMapping('body:format', 'format')->callbacks(array(
      $this,
      'migrate_hrweb_get_text_format_by_id'
    ));

  }

  /**
   * Translate between D6 input format id and D7 text format name.
   * For use with prepare_row()
   */
  protected function migrate_hrweb_get_text_format_by_id($id) {
    $output = '';

    switch ($id) {
      /*
        case 1:
          //D6: filtered html
        case 2:
          //D6: full html
          case 4:
          //D6: Editor
      */
      case 3:
        //D6: Webmaster
        $output = 'panopoly_html_text';
        break;

      default:
        $output = 'editor';
      //'panopoly_wysiwyg_text';
    }

    return $output;
  }

  /*
   * When you transform the contents of a field, you seem to need to use prepare() as opposed to prepareRow()
   */
  public function prepare($node, stdClass $row) {
    /*
     * Translate links like
     *    a href="internal:node/111"
     * generated by LinkIt to
     *    a href="internal:node/222"
     * where 111 represents a nid in the source db and 222 represents the corresponding nid in the destination db.
     */
    $node->body[LANGUAGE_NONE][0]['value'] = preg_replace_callback("|(href=\"?[a-zA-Z/]+:node/)(\d+)|", 'self::getDestinationNid', $node->body[LANGUAGE_NONE][0]['value']);


    return TRUE;
  }

  protected function getDestinationNid($matches) {
    // as usual: $matches[0] is the complete match
    // $matches[1] the match for the first pattern
    // enclosed in '(...)' and so on

    //Find the node_type of the source nid
    $result = Database::getConnection('default', $this->sourceConnection)
      ->query("SELECT type FROM node WHERE nid=:nid", array(':nid' => $matches[2]));
    if ($result) {
      $source_type = $result->fetchField();
    }

    /*
     * Find the migration that operates on $source_type.
     * The nid that is linked to in the body may or may not be of the same
     * content-type (and migration) as the node that we are operating on. E.g.
     * a Basic Page may link to a Book Page.
     */
    $migrations = $this->getMigrations();
    $migration_machine_name = FALSE;
    while (list($k, $v) = each($migrations)) {
      if ($v->sourceType == $source_type) {
        $migration_machine_name = $k;
        break;
      }
    }

    //Find the destination nid that corresponds to the source nid
    if ($migration_machine_name) {
      $dest_nid = parent::handleSourceMigration($migration_machine_name, $matches[2]);
    }
    else {
      $dest_nid = "not-found";
      drupal_set_message("Source nid=" . $matches[2] . " of type $source_type could not be associated with a migration.", "error");
    }
    return $matches[1] . $dest_nid;
  }

  private function getMigrations() {
    //Only look up migrations once.
    static $migrations = array();
    if (count($migrations) == 0) {
      $migrations = migrate_migrations();
      drupal_set_message("Looked up migrations. (This should only happen once.)");
    }
    return $migrations;
  }

}

class HrwebAvccornerMigration extends HrwebNodeMigration {
  public function __construct(array $arguments) {

    parent::__construct($arguments);

    //Map non-standard body field
    $this->addFieldMapping('body', 'field_body');

  }
}

class HrwebGlossaryMigration extends HrwebNodeMigration {
  public function __construct(array $arguments) {

    parent::__construct($arguments);

    //Map non-standard body field
    $this->addFieldMapping('body', 'field_body');

  }
}

class HrwebRelatedLinkMigration extends HrwebNodeMigration {
  public function __construct(array $arguments) {

    parent::__construct($arguments);

    //Map non-standard body field
    $this->addFieldMapping('body', 'field_body');

    //Related links categoies vocab id = 5 in source
    $this->addFieldMapping('field_link_category', 5)
      ->sourceMigration('related_links_categories')
      ->arguments(array('source_type' => 'tid'));


  }
}

class HrwebRelatedLinkAttachmentMigration extends HrwebRelatedLinkMigration {

  public function __construct(array $arguments) {
    parent::__construct($arguments);
  }

  /*
   * When you transform the contents of a field, you seem to need to use prepare() as opposed to prepareRow()
   */
  public function prepare($node, stdClass $row) {

    if ((strpos($node->body[LANGUAGE_NONE][0]['summary'], 'hrweb.berkeley.edu/files')) ||
      (strpos($node->body[LANGUAGE_NONE][0]['summary'], 'href="/files'))
    ) {
      $node->body[LANGUAGE_NONE][0]['summary'] = str_replace('/files', '/sites/default/files', $node->body[LANGUAGE_NONE][0]['summary']);
    }

    return TRUE;
  }
}

class HrwebSlideMigration extends HrwebNodeMigration {
  public function __construct(array $arguments) {

    parent::__construct($arguments);

    //Map non-standard body field
    $this->addFieldMapping('field_slide_pager_item_text', 'field_pager_item_text');
    $this->addFieldMapping('field_slide_url', 'field_url');

    $this->addFieldMapping('field_slide_image', 'field_image')
      ->sourceMigration('AllFiles');
    $this->addFieldMapping('field_slide_image:file_class')
      ->defaultValue('MigrateFileFid');
    $this->addFieldMapping('field_slide_image:preserve_files')
      ->defaultValue(TRUE);
  }
}

class HrwebFaqMigration extends HrwebNodeMigration {
  public function __construct(array $arguments) {
    parent::__construct($arguments);

    //Related links categoies vocab id = 5 in source
    $this->addFieldMapping('field_faq_category', 4)
      ->sourceMigration('faqs')
      ->arguments(array('source_type' => 'tid'));

  }

  public function query() {
    $query = parent::query();

    $subquery = Database::getConnection('default', $this->sourceConnection)
      ->select('node_revisions', 'nr')
      ->fields('nr', array('nid'));
    $subquery->addExpression('MAX(nr.vid)', 'vid');
    $subquery->groupBy('nr.nid');


    $query->addJoin('INNER', $subquery, 'subnr', 'n.nid=subnr.nid AND n.vid=subnr.vid');
    $query->join('faq_questions', 'fq', 'fq.nid=n.nid AND fq.vid=n.vid');
    $query->leftJoin('faq_weights', 'w', 'w.nid=n.nid');
    $query->addField('fq', 'question');
    $query->addField('fq', 'detailed_question');
    $query->addField('w', 'weight');
    $query->addField('w', 'tid');
    //$x = Database::getConnection()->prefixTables($query);
    return $query;
  }

  public function prepareRow($current_row) {
    // Always start your prepareRow implementation with this clause. You need to
    // be sure your parent classes have their chance at the row, and that if
    // they return FALSE (indicating the row should be skipped) you pass that
    // on.
    if (parent::prepareRow($current_row) === FALSE) {
      return FALSE;
    }

    // get rid of the path that uses the source's nid. correct path will
    // be created on save
    unset($current_row->path);
    return TRUE;
  }

  /**
   * Code to run before first row is imported
   */
  public function preImport() {
    parent::preImport();
    /*
     * If the faq module is enabled, faq_insert() and/or faq_update() may try to
     * run resulting in migrate log messages like:
     *       2461        Undefined property: stdClass::$detailed_question
             2461        SQLSTATE[23000]: Integrity constraint violation:
                         1062 Duplicate entry '8525-9641' for
                         key 'PRIMARY'
     */
    if (module_exists('faq')) {
      module_disable(array('faq'));
      drupal_set_message("Now, now Drupal, those module disable/enable lines were not errors. --Brian");
    }
  }

  /**
   * Code to run after last row is imported
   */
  public function postImport() {
    parent::postImport();
    /*
     * Since we just imported faq content, you probably want this module
     * enabled so you can test things out.
     */
    module_enable(array('faq'));
  }

  /**
   * Code to execute after the last article row has been deleted
   */
  public function postRollback() {
    parent::postRollback();
    db_truncate('faq_questions')->execute();
    drupal_set_message("Truncated faq_questions table!");
    drupal_set_message("Partial rollbacks of Faq are NOT supported.  Don't attempt migrate-rollback with arguments like --idlist.", "warning");
  }

  /**
   * Acts right after a node has been saved.
   *
   * @param object $node
   *   A node object for the newly migrated node.
   * @param stdClass $row
   *   An object representing data from the source row.
   */
  public function complete($node, stdClass $row) {

    // update or insert into faq_weights
    // lifted from faq.admin.inc: faq_order_settings_reorder_form_submit()
    db_merge('faq_weights')
      ->fields(array(
        'weight' => (int) $row->weight,
      ))
      ->key(array(
        'tid' => $node->field_faq_category[LANGUAGE_NONE][0]['tid'],
        'nid' => $node->nid,
      ))
      ->execute();

    //insert into faq_question
    db_merge('faq_questions')
      ->fields(array(
        'question' => $node->title,
        'detailed_question' => $row->detailed_question,
      ))
      ->key(array(
        'nid' => $node->nid,
        'vid' => $node->vid,
      ))
      ->execute();


  }


}

class HrwebBookPageMigration extends HrwebNodeMigration {
  public function __construct(array $arguments) {
    parent::__construct($arguments);
  }

  /**
   * Overrides parent::query to add more data to the source, in our case,
   * book hierarchy stuff.
   */
  public function query() {
    $query = parent::query();
    // Add in book parent child relationships.
    $query->join('book', 'b', 'n.nid = b.nid');
    $query->addField('b', 'bid', 'book_id');
    $query->join('menu_links', 'ml', 'b.mlid = ml.mlid');
    $query->addField('ml', 'weight', 'book_weight');
    //Query extention to get nid of parent from the link path in menu_links (could get it elsewhere)
    $query->leftJoin('menu_links', 'mm', 'ml.plid = mm.mlid');
    $query->addField('mm', 'link_path', 'parent_id');
    // Sort by depth so there is always a parent
    $query->orderBy('ml.depth');

    //$x = Database::getConnection()->prefixTables($query);
    return $query;
  }

  /**
   * Acts right after a book node has been saved. Map the book hierarchy.
   *
   * @param object $node
   *   A node object for the newly migrated book.
   * @param stdClass $row
   *   An object representing data from the source row.
   */
  public function complete($node, stdClass $row) {
    // If this is a top-level book, don't set a parent.
    $book_id = $row->nid == $row->book_id ? $node->nid : parent::handleSourceMigration('BookPage', $row->book_id);

    // bid: If this is a top-level book, don't set a parent.
    //$book_id = $row->nid == $row->book_id ? $node->nid : $this->lookupMigratedBook($row->book_id);
    // Book id - effectively, parent nid.
    $node->book['bid'] = $book_id;
    $node->book['nid'] = $node->nid;
    $node->book['weight'] = $row->book_weight;

    // We strip the "node/"-part from the link_path
    $parent_id = str_replace("node/", "", $row->parent_id);
    // If there is a parent we lookup the migrated node
    if (isset($parent_id) && $parent_id > 0) {
      $parent_node = parent::handleSourceMigration('BookPage', $parent_id);
      // We get the mlid of the migrated parent
      $query = db_select("menu_links", "ml")
        ->fields("ml")
        ->condition("ml.link_path", "node/" . $parent_node, "=")
        ->execute()
        ->fetchAssoc();
      $plid = $query['mlid'];
      // We add the parent mlid (plid)
      $node->book['plid'] = $plid;
      /**
       * left off
       * $plid is null when row->nid=78 bc mlid hasn't been created for 77
       */
    }

    _book_update_outline($node);
    node_save($node);

  }

  /**
   * Returns the book id for the book that this Page is part of
   *
   * @param int $source_book_nid
   *   Nid of book in source database to lookup.
   */
  protected function lookupMigratedParentPage($source_plid) {
    $dest_plid = parent::handleSourceMigration('BookPage', $source_plid);
    return $dest_plid;
  }


  /**
   * Returns the book id for the book that this Page is part of
   *
   * @param int $source_book_nid
   *   Nid of book in source database to lookup.
   */
  protected function lookupMigratedBook($source_book_nid) {
    $dest_book_nid = parent::handleSourceMigration('BookPage', $source_book_nid);
    return $dest_book_nid;
  }

}
