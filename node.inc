<?php

/**
 * Common mappings for the Drupal 6 node migrations.
 */
class HrwebNodeMigration extends DrupalNode6Migration {

  public function __construct(array $arguments) {
    parent::__construct($arguments);
    //Map D6 input formats to OB text formats

    //Set $warn_on_override to FALSE to suppress warning messages: http://drupalcontrib.org/api/drupal/contributions!migrate!includes!migration.inc/function/Migration%3A%3AaddFieldMapping/7

    $this->addFieldMapping('body:format', 'format', FALSE)->callbacks(array(
      $this,
      'migrate_hrweb_get_text_format_by_id'
    ));
    $this->addFieldMapping('path', 'path', FALSE);
    // this line requires the deprecated module migrate_extras
    // https://jira.berkeley.edu/browse/DRUPALOPS-101?focusedCommentId=158227&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-158227
    // https://drupal.org/node/2023657#comment-7562763
    $this->addFieldMapping('pathauto', NULL, FALSE)->defaultValue(0);

  }

  /**
   * Translate between D6 input format id and D7 text format name.
   * For use with prepare_row()
   */
  protected function migrate_hrweb_get_text_format_by_id($id) {
    $output = '';

    switch ($id) {
      /*
        case 1:
          //D6: filtered html
        case 2:
          //D6: full html
          case 4:
          //D6: Editor
      */
      case 3:
        //D6: Webmaster
        $output = 'panopoly_html_text';
        break;

      default:
        $output = 'editor';
    }
    return $output;
  }

  /**
   * Code to run before first row is imported
   */
  public function preImport() {
    if (module_exists('redirect')) {
      //Settings for /admin/config/search/path/patterns
      variable_set('pathauto_node_pattern', '[node:menu-link:parents:join-path]/[node:title]');
      variable_set('pathauto_node_panopoly_page_pattern', '[node:menu-link:parents:join-path]/[node:title]');
    }


  }

  /*
   * When you transform the contents of a field, you seem to need to use prepare() as opposed to prepareRow()
   */
  public function prepare($node, stdClass $row) {
    /*
     * Translate links like
     *    a href="internal:node/111"
     * generated by LinkIt to
     *    a href="internal:node/222"
     * where 111 represents a nid in the source db and 222 represents the corresponding nid in the destination db.
     */
    $node->body[LANGUAGE_NONE][0]['value'] = preg_replace_callback("|(href=\"?[a-zA-Z/]+:)([nodefaq]+/)(\d+)|", 'self::getDestinationNid', $node->body[LANGUAGE_NONE][0]['value']);
    //There don't seem to be bad links in the summaries, or summaries aren't displayed
    //$node->body[LANGUAGE_NONE][0]['summary'] = preg_replace_callback("|(href=\"?[a-zA-Z/]+:node/)(\d+)|", 'self::getDestinationNid', $node->body[LANGUAGE_NONE][0]['summary']);


    //Replace href=foo.com/files/bar with href=foo.com/sites/default/files/bar
    //but don't replace href=foo.com/sites/default/files/bar
    $node->body[LANGUAGE_NONE][0]['value'] = preg_replace("|(href=\"?[a-zA-Z\./:\d]*(?<!sites/default/))files/([^>]+)|", '\\1sites/default/files/\\2', $node->body[LANGUAGE_NONE][0]['value']);

    //Remove "../../" in urls
    $node->body[LANGUAGE_NONE][0]['value'] = preg_replace("|(href=\"?[a-zA-Z:/.\d]*)(\.\./\.\./)([^>]+)|", "$1$3", $node->body[LANGUAGE_NONE][0]['value']);
    //Remove "../" in urls
    $node->body[LANGUAGE_NONE][0]['value'] = preg_replace("|(href=\"?[a-zA-Z:/.\d]*)(\.\./)([^>]+)|", "$1$3", $node->body[LANGUAGE_NONE][0]['value']);

    return TRUE;
  }

  protected function getDestinationNid($matches) {
    // as usual: $matches[0] is the complete match
    // $matches[1] the match for the first pattern
    // enclosed in '(...)' and so on

    //Find the node_type of the source nid
    $result = Database::getConnection('default', $this->sourceConnection)
      ->query("SELECT type FROM node WHERE nid=:nid", array(':nid' => $matches[3]));
    if ($result) {
      $source_type = $result->fetchField();
    }

    $migration_machine_name = FALSE;

    /*
     * If the path contains 'faq/' we know it's a Faq node handled by the Faq
     * migration.  Otherwise, find the migration that matches the $source_type
     */
    if (strpos($matches[2], 'faq/') !== FALSE) {
      $migration_machine_name = 'Faq';
    }
    else {
      /*
       * Find the migration that operates on $source_type.
       * The nid that is linked to in the body may or may not be of the same
       * content-type (and migration) as the node that we are operating on. E.g.
       * a Basic Page may link to a Book Page.
       */
      $migrations = $this->getMigrations();
      while (list($k, $v) = each($migrations)) {
        if ($v->sourceType == $source_type) {
          $migration_machine_name = $k;
          break;
        }
      }
    }


    if ($migration_machine_name == 'Faq') {
      // Is this a link to an faq sub-category or to an individual faq node?
      // Is it a sub category link?
      $sub_cat = FALSE;
      $result = Database::getConnection('default', $this->sourceConnection)
        ->query("SELECT name FROM term_data WHERE tid=:tid", array(':tid' => $matches[3]));
      if ($result) {
        $sub_cat = $result->fetchField();
      }

      if ($sub_cat) {
        //D7 to link to a faq sub-category it's faq-page/$tid
        $matches[2] = 'faq-page/';
        //'faqs' is the machine name for the FAQ taxonomy migration
        $dest_id = parent::handleSourceMigration('faqs', $matches[3]);
      }
      else {
        //Not a sub-category link, so assume it's a link to an individual faq
        //'Faq' is the machine name for the FAQ node migration
        $matches[2] = 'node/';
        $dest_id = parent::handleSourceMigration('Faq', $matches[3]);
      }

    }
    elseif ($migration_machine_name !== FALSE) {
      //Find the destination nid that corresponds to the source nid
      $dest_id = parent::handleSourceMigration($migration_machine_name, $matches[3]);
    }
    else {
      $dest_id = "not-found";
      drupal_set_message("Source nid=" . $matches[3] . " of type $source_type could not be associated with a migration.", "error");
    }
    return $matches[1] . $matches[2] . $dest_id;
  }

  private function getMigrations() {
    //Only look up migrations once.
    static $migrations = array();
    if (count($migrations) == 0) {
      $migrations = migrate_migrations();
      drupal_set_message("Looked up migrations. (This should only happen once.)");
    }
    return $migrations;
  }

}

class HrwebAvccornerMigration extends HrwebNodeMigration {
  public function __construct(array $arguments) {

    parent::__construct($arguments);

    //Map non-standard body field
    $this->addFieldMapping('body', 'field_body', FALSE);

  }
}

class HrwebGlossaryMigration extends HrwebNodeMigration {
  public function __construct(array $arguments) {

    parent::__construct($arguments);

    //Map non-standard body field
    $this->addFieldMapping('body', 'field_body', FALSE);

  }
}

class HrwebRelatedLinkMigration extends HrwebNodeMigration {
  public function __construct(array $arguments) {

    parent::__construct($arguments);

    //Map non-standard body field
    $this->addFieldMapping('body', 'field_body', FALSE);

    //Related links categoies vocab id = 5 in source
    $this->addFieldMapping('field_link_category', 5)
      ->sourceMigration('related_links_categories')
      ->arguments(array('source_type' => 'tid'));


  }
}

class HrwebRelatedLinkAttachmentMigration extends HrwebRelatedLinkMigration {

  public function __construct(array $arguments) {
    parent::__construct($arguments);
  }

  /*
   * When you transform the contents of a field, you seem to need to use prepare() as opposed to prepareRow()
   */
  public function prepare($node, stdClass $row) {

    if ((strpos($node->body[LANGUAGE_NONE][0]['summary'], 'hrweb.berkeley.edu/files')) ||
      (strpos($node->body[LANGUAGE_NONE][0]['summary'], 'href="/files'))
    ) {
      $node->body[LANGUAGE_NONE][0]['summary'] = str_replace('/files', '/sites/default/files', $node->body[LANGUAGE_NONE][0]['summary']);
    }

    return TRUE;
  }
}

class HrwebSlideMigration extends HrwebNodeMigration {
  public function __construct(array $arguments) {

    parent::__construct($arguments);

    //Map non-standard body field
    $this->addFieldMapping('field_slide_pager_item_text', 'field_pager_item_text', FALSE);
    $this->addFieldMapping('field_slide_url', 'field_url', FALSE);

    $this->addFieldMapping('field_slide_image', 'field_image', FALSE)
      ->sourceMigration('AllFiles');
    $this->addFieldMapping('field_slide_image:file_class', FALSE)
      ->defaultValue('MigrateFileFid');
    $this->addFieldMapping('field_slide_image:preserve_files', FALSE)
      ->defaultValue(TRUE);
  }
}

class HrwebFaqMigration extends HrwebNodeMigration {
  public function __construct(array $arguments) {
    parent::__construct($arguments);

    //Related links categoies vocab id = 5 in source
    $this->addFieldMapping('field_faq_category', 4, FALSE)
      ->sourceMigration('faqs')
      ->arguments(array('source_type' => 'tid'));

  }

  public function query() {
    $query = parent::query();

    $subquery = Database::getConnection('default', $this->sourceConnection)
      ->select('node_revisions', 'nr')
      ->fields('nr', array('nid'));
    $subquery->addExpression('MAX(nr.vid)', 'vid');
    $subquery->groupBy('nr.nid');


    $query->addJoin('INNER', $subquery, 'subnr', 'n.nid=subnr.nid AND n.vid=subnr.vid');
    $query->join('faq_questions', 'fq', 'fq.nid=n.nid AND fq.vid=n.vid');
    $query->leftJoin('faq_weights', 'w', 'w.nid=n.nid');
    $query->addField('fq', 'question');
    $query->addField('fq', 'detailed_question');
    $query->addField('w', 'weight');
    $query->addField('w', 'tid');
    //$x = Database::getConnection()->prefixTables($query);
    return $query;
  }

  public function prepareRow($current_row) {
    // Always start your prepareRow implementation with this clause. You need to
    // be sure your parent classes have their chance at the row, and that if
    // they return FALSE (indicating the row should be skipped) you pass that
    // on.
    if (parent::prepareRow($current_row) === FALSE) {
      return FALSE;
    }

    // get rid of the path that uses the source's nid. correct path will
    // be created on save
    unset($current_row->path);
    return TRUE;
  }

  /**
   * Code to run before first row is imported
   */
  public function preImport() {
    parent::preImport();
    if ((module_exists('faq') && module_exists('redirect'))) {
      //Set paths at /admin/config/search/path/patterns
      variable_set('pathauto_node_faq_pattern', 'faq/[node:nid]');
      variable_set('pathauto_faq_pattern', 'faq/[term:name]');
    }
  }

  /**
   * Code to run after last row is imported
   */
  public function postImport() {
    parent::postImport();
    /*
     * Since we just imported faq content, you probably want this module
     * enabled so you can test things out.
     */
    //module_enable(array('faq'));

    //redirect the D6 url for the Faq page to the D7 version
    if (module_exists('redirect')) {
      $redirect = new stdClass();
      redirect_object_prepare(
        $redirect,
        array(
          'source' => 'faq',
          'source_options' => array(),
          'redirect' => 'faq-page',
          'redirect_options' => array(),
          'language' => LANGUAGE_NONE,
        )
      );
      redirect_save($redirect);
    }

  }

  /**
   * Code to execute after the last article row has been deleted
   */
  public function postRollback() {
    parent::postRollback();
    db_truncate('faq_questions')->execute();
    drupal_set_message("Truncated faq_questions table!");
    drupal_set_message("Partial rollbacks of Faq are NOT supported.  Don't attempt migrate-rollback with arguments like --idlist.", "warning");

    if (module_exists('redirect')) {
      // if you don't remove you'll get "duplicate entry for key on next import."
      redirect_delete_by_path('faq-page');
    }

  }

  /**
   * Acts right after a node has been saved.
   *
   * @param object $node
   *   A node object for the newly migrated node.
   * @param stdClass $row
   *   An object representing data from the source row.
   */
  public function complete($node, stdClass $row) {

    // update or insert into faq_weights
    // lifted from faq.admin.inc: faq_order_settings_reorder_form_submit()
    db_merge('faq_weights')
      ->fields(array(
        'weight' => (int) $row->weight,
      ))
      ->key(array(
        'tid' => $node->field_faq_category[LANGUAGE_NONE][0]['tid'],
        'nid' => $node->nid,
      ))
      ->execute();

    //insert into faq_question
    db_merge('faq_questions')
      ->fields(array(
        'question' => $node->title,
        'detailed_question' => $row->detailed_question,
      ))
      ->key(array(
        'nid' => $node->nid,
        'vid' => $node->vid,
      ))
      ->execute();


  }


}

class HrwebBookPageMigration extends HrwebNodeMigration {
  public function __construct(array $arguments) {
    parent::__construct($arguments);
  }

  /**
   * Overrides parent::query to add more data to the source, in our case,
   * book hierarchy stuff.
   */
  public function query() {
    //$query = parent::query(); //override becuase we don't want the Order By applied by the parent and since the object is protected, we can't just unset it.

    //copy begin
    $query = Database::getConnection('default', $this->sourceConnection)
      ->select('node', 'n')
      ->fields('n', array('nid', 'vid', 'language', 'title',
        'uid', 'status', 'created', 'changed', 'comment', 'promote',
        'moderate', 'sticky', 'tnid', 'translate'))
      ->condition('n.type', $this->sourceType);
//      ->orderBy('n.changed'); // <-----------------Remove order
    $query->innerJoin('node_revisions', 'nr', 'n.vid=nr.vid');
    $query->fields('nr', array('body', 'teaser', 'format'));
    // Pick up simple CCK fields
    $cck_table = 'content_type_' . $this->sourceType;
    if (Database::getConnection('default', $this->sourceConnection)
      ->schema()->tableExists($cck_table)) {
      $query->leftJoin($cck_table, 'f', 'n.vid=f.vid');
      // The main column for the field should be rendered with
      // the field name, not the column name (e.g., field_foo rather
      // than field_foo_value).
      $field_info = $this->version->getSourceFieldInfo();
      foreach ($field_info as $field_name => $info) {
        if (isset($info['columns']) && !$info['multiple'] && $info['db_storage']) {
          $i = 0;
          foreach ($info['columns'] as $display_name => $column_name) {
            if ($i++ == 0) {
              $query->addField('f', $column_name, $field_name);
            }
            else {
              // The database API won't allow colons in column aliases, so we
              // will accept the default alias, and fix up the field names later.
              // Remember how to translate the field names.
              $clean_name = str_replace(':', '_', $display_name);
              $this->fixFieldNames[$clean_name] = $display_name;
              $query->addField('f', $column_name);
            }
          }
        }
      }
    }
    //copy end

    // Add in book parent child relationships.
    $query->join('book', 'b', 'n.nid = b.nid');
    $query->addField('b', 'bid', 'book_id');
    $query->join('menu_links', 'ml', 'b.mlid = ml.mlid');
    $query->addField('ml', 'weight', 'book_weight');
    //Query extention to get nid of parent from the link path in menu_links (could get it elsewhere)
    $query->leftJoin('menu_links', 'mm', 'ml.plid = mm.mlid');
    $query->addExpression('CAST(SUBSTRING(mm.link_path, 6) as UNSIGNED)', 'parent_id');
    //$query->addExpression('SUBSTRING(mm.link_path, 6)', 'parent_id');
    // Sort by depth, then parent_id
    $query->orderBy('ml.depth');
    $query->orderBy('parent_id');
    $x = Database::getConnection()->prefixTables($query);
    return $query;
  }

  /**
   * Acts right after a book node has been saved. Map the book hierarchy.
   *
   * @param object $node
   *   A node object for the newly migrated book.
   * @param stdClass $row
   *   An object representing data from the source row.
   */
  public function complete($node, stdClass $row) {
    // If this is a top-level book, don't set a parent.
    $book_id = $row->nid == $row->book_id ? $node->nid : parent::handleSourceMigration('BookPage', $row->book_id);

    // bid: If this is a top-level book, don't set a parent.
    //$book_id = $row->nid == $row->book_id ? $node->nid : $this->lookupMigratedBook($row->book_id);
    // Book id - effectively, parent nid.
    $node->book['bid'] = $book_id;
    $node->book['nid'] = $node->nid;
    $node->book['weight'] = $row->book_weight;

    // We strip the "node/"-part from the link_path
    //$parent_id = str_replace("node/", "", $row->parent_id);
    $parent_id = $row->parent_id;

    // If there is a parent we lookup the migrated node
    if (isset($parent_id) && $parent_id > 0) {
      $parent_node = parent::handleSourceMigration('BookPage', $parent_id);
      // We get the mlid of the migrated parent
      $query = db_select("menu_links", "ml")
        ->fields("ml")
        ->condition("ml.link_path", "node/" . $parent_node, "=")
        ->execute()
        ->fetchAssoc();
      $plid = $query['mlid'];

      //if $parent_node is a stub it won't have a plid yet, make sure it has one
      /*
      if (($plid === NULL) && ($parent_node > 0)) {

      }
*/
      // We add the parent mlid (plid)
      $node->book['plid'] = $plid;
    }

    _book_update_outline($node);
    node_save($node);

  }
/*
  protected function createStub($migration, $source_key) {
    $x=1;

  }
*/
  /**
   * Returns the book id for the book that this Page is part of
   *
   * @param int $source_book_nid
   *   Nid of book in source database to lookup.
   */
  protected function lookupMigratedParentPage($source_plid) {
    $dest_plid = parent::handleSourceMigration('BookPage', $source_plid);
    return $dest_plid;
  }


  /**
   * Returns the book id for the book that this Page is part of
   *
   * @param int $source_book_nid
   *   Nid of book in source database to lookup.
   */
  protected function lookupMigratedBook($source_book_nid) {
    $dest_book_nid = parent::handleSourceMigration('BookPage', $source_book_nid);
    return $dest_book_nid;
  }

}
